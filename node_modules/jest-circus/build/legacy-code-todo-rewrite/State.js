'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.testNameToKey =
  exports.removeLinesBeforeExternalMatcherTrap =
  exports.keyToTestName =
  exports.SnapshotState =
    void 0;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

const keyToTestName = key => {
  if (!/ \d+$/.test(key)) {
    throw new Error('Snapshot keys must end with a number.');
  }
  return key.replace(/ \d+$/, '');
};
exports.keyToTestName = keyToTestName;
const removeLinesBeforeExternalMatcherTrap = stack => {
  const lines = stack.split('\n');
  for (let i = 0; i < lines.length; i += 1) {
    // It's a function name specified in `packages/expect/src/index.ts`
    // for external custom matchers.
    if (lines[i].includes('__EXTERNAL_MATCHER_TRAP__')) {
      return lines.slice(i + 1).join('\n');
    }
  }
  return stack;
};
exports.removeLinesBeforeExternalMatcherTrap =
  removeLinesBeforeExternalMatcherTrap;
const testNameToKey = (testName, count) => `${testName} ${count}`;
exports.testNameToKey = testNameToKey;
class SnapshotState {
  _counters;
  _dirty;
  _index;
  _updateSnapshot;
  _snapshotData;
  _initialData;
  _snapshotPath;
  _inlineSnapshots;
  _uncheckedKeys;
  _prettierPath;
  _rootDir;
  snapshotFormat;
  added;
  expand;
  matched;
  unmatched;
  updated;
  constructor(snapshotPath, options) {
    this._snapshotPath = snapshotPath;
    const {data, dirty} = {
      data: {},
      dirty: false
    };
    this._initialData = data;
    this._snapshotData = data;
    this._dirty = dirty;
    this._prettierPath = options.prettierPath ?? null;
    this._inlineSnapshots = [];
    this._uncheckedKeys = new Set(Object.keys(this._snapshotData));
    this._counters = new Map();
    this._index = 0;
    this.expand = options.expand || false;
    this.added = 0;
    this.matched = 0;
    this.unmatched = 0;
    this._updateSnapshot = options.updateSnapshot;
    this.updated = 0;
    this.snapshotFormat = options.snapshotFormat;
    this._rootDir = options.rootDir;
  }
  markSnapshotsAsCheckedForTest(testName) {
    // this._uncheckedKeys.forEach(uncheckedKey => {
    //   if (keyToTestName(uncheckedKey) === testName) {
    //     this._uncheckedKeys.delete(uncheckedKey);
    //   }
    // });
  }
  _addSnapshot(key, receivedSerialized, options) {
    // this._dirty = true;
    // if (options.isInline) {
    //   const error = options.error || new Error();
    //   const lines = getStackTraceLines(
    //     removeLinesBeforeExternalMatcherTrap(error.stack || ''),
    //   );
    //   const frame = getTopFrame(lines);
    //   if (!frame) {
    //     throw new Error(
    //       "Jest: Couldn't infer stack frame for inline snapshot.",
    //     );
    //   }
    //   this._inlineSnapshots.push({
    //     frame,
    //     snapshot: receivedSerialized,
    //   });
    // } else {
    //   this._snapshotData[key] = receivedSerialized;
    // }
  }
  clear() {
    this._snapshotData = this._initialData;
    this._inlineSnapshots = [];
    this._counters = new Map();
    this._index = 0;
    this.added = 0;
    this.matched = 0;
    this.unmatched = 0;
    this.updated = 0;
  }
  save() {
    const hasExternalSnapshots = Object.keys(this._snapshotData).length;
    const hasInlineSnapshots = this._inlineSnapshots.length;
    const isEmpty = !hasExternalSnapshots && !hasInlineSnapshots;
    const status = {
      deleted: false,
      saved: false
    };

    // if ((this._dirty || this._uncheckedKeys.size) && !isEmpty) {
    //   if (hasExternalSnapshots) {
    //     // saveSnapshotFile(this._snapshotData, this._snapshotPath);
    //   }
    //   if (hasInlineSnapshots) {
    //     // saveInlineSnapshots(
    //     //   this._inlineSnapshots,
    //     //   this._rootDir,
    //     //   this._prettierPath,
    //     // );
    //   }
    //   status.saved = true;
    // } else if (!hasExternalSnapshots && fs.existsSync(this._snapshotPath)) {
    //   if (this._updateSnapshot === 'all') {
    //     fs.unlinkSync(this._snapshotPath);
    //   }
    //   status.deleted = true;
    // }

    return status;
  }
  getUncheckedCount() {
    return this._uncheckedKeys.size || 0;
  }
  getUncheckedKeys() {
    return Array.from(this._uncheckedKeys);
  }
  removeUncheckedKeys() {
    if (this._updateSnapshot === 'all' && this._uncheckedKeys.size) {
      this._dirty = true;
      this._uncheckedKeys.forEach(key => delete this._snapshotData[key]);
      this._uncheckedKeys.clear();
    }
  }
  match({testName, received, key, inlineSnapshot, isInline, error}) {
    return {
      actual: '',
      count: 0,
      expected: '',
      key,
      pass: true
    };
  }
  fail(testName, _received, key) {
    this._counters.set(testName, (this._counters.get(testName) || 0) + 1);
    const count = Number(this._counters.get(testName));
    if (!key) {
      key = testNameToKey(testName, count);
    }
    this._uncheckedKeys.delete(key);
    this.unmatched++;
    return key;
  }
}
exports.SnapshotState = SnapshotState;
